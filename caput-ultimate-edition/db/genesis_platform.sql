-- genesis_platform.sql
-- GENESIS Platform Database Schema
-- Copyright (c) 2025 MuzzL3d Dictionary Contributors â€” Apache-2.0

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ========================================
-- SCHEMA: IDENTITIES
-- ========================================

CREATE SCHEMA IF NOT EXISTS identities;

CREATE TABLE identities.account (
  id                BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  subject_id        TEXT UNIQUE NOT NULL,
  email             TEXT UNIQUE NOT NULL,
  name              TEXT NOT NULL DEFAULT '',
  provider          TEXT NOT NULL CHECK (provider IN ('bitwarden', 'google', 'azure', 'local')),
  mfa_enabled       BOOLEAN NOT NULL DEFAULT false,
  roles             TEXT[] NOT NULL DEFAULT '{}',
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_login        TIMESTAMPTZ,
  active            BOOLEAN NOT NULL DEFAULT true
);

CREATE INDEX idx_account_email ON identities.account(email);
CREATE INDEX idx_account_provider ON identities.account(provider);
CREATE INDEX idx_account_subject_id ON identities.account(subject_id);

-- ========================================
-- SCHEMA: CLAIMS
-- ========================================

CREATE SCHEMA IF NOT EXISTS claims;

CREATE TABLE claims.claim (
  id                BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  subject_id        TEXT NOT NULL,
  claim_type        TEXT NOT NULL,
  claim_value       JSONB NOT NULL,
  issuer            TEXT NOT NULL DEFAULT 'genesis',
  issued_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
  expires_at        TIMESTAMPTZ,
  revoked           BOOLEAN NOT NULL DEFAULT false,
  revoked_at        TIMESTAMPTZ,
  revoked_reason    TEXT
);

CREATE INDEX idx_claim_subject_id ON claims.claim(subject_id);
CREATE INDEX idx_claim_type ON claims.claim(claim_type);
CREATE INDEX idx_claim_issued_at ON claims.claim(issued_at DESC);
CREATE INDEX idx_claim_value_gin ON claims.claim USING GIN (claim_value);

-- ========================================
-- SCHEMA: EVIDENCE
-- ========================================

CREATE SCHEMA IF NOT EXISTS evidence;

CREATE TABLE evidence.bundle (
  id                BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  bundle_uuid       UUID NOT NULL DEFAULT uuid_generate_v4(),
  subject_id        TEXT NOT NULL,
  doc_type          TEXT NOT NULL,
  doc_hash          BYTEA NOT NULL,
  sig_ed25519       BYTEA NOT NULL,
  public_key        BYTEA NOT NULL,
  signed_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
  meta              JSONB NOT NULL DEFAULT '{}',
  created_by        TEXT NOT NULL,
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_bundle_subject_id ON evidence.bundle(subject_id);
CREATE INDEX idx_bundle_uuid ON evidence.bundle(bundle_uuid);
CREATE INDEX idx_bundle_doc_type ON evidence.bundle(doc_type);
CREATE INDEX idx_bundle_signed_at ON evidence.bundle(signed_at DESC);
CREATE INDEX idx_bundle_meta_gin ON evidence.bundle USING GIN (meta);

-- ========================================
-- SCHEMA: LEDGER (append-only, hash-chained)
-- ========================================

CREATE SCHEMA IF NOT EXISTS ledger;

CREATE TABLE ledger.entry (
  id                BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  prev_hash         BYTEA,
  entry_hash        BYTEA NOT NULL,
  entry_type        TEXT NOT NULL,
  payload           JSONB NOT NULL,
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by        TEXT NOT NULL DEFAULT 'system'
);

CREATE INDEX idx_entry_type ON ledger.entry(entry_type);
CREATE INDEX idx_entry_created_at ON ledger.entry(created_at DESC);
CREATE INDEX idx_entry_prev_hash ON ledger.entry(prev_hash);

-- Auto-compute entry_hash on insert (SHA-256 chain)
CREATE OR REPLACE FUNCTION ledger.compute_entry_hash()
RETURNS TRIGGER AS $$
BEGIN
  NEW.entry_hash = digest(
    COALESCE(NEW.prev_hash::text, '') ||
    NEW.entry_type ||
    NEW.payload::text ||
    NEW.created_at::text,
    'sha256'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_compute_entry_hash
  BEFORE INSERT ON ledger.entry
  FOR EACH ROW
  EXECUTE FUNCTION ledger.compute_entry_hash();

-- ========================================
-- SCHEMA: AUDIT (append-only)
-- ========================================

CREATE SCHEMA IF NOT EXISTS audit;

CREATE TABLE audit.log (
  id                BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  timestamp         TIMESTAMPTZ NOT NULL DEFAULT now(),
  user_email        TEXT NOT NULL DEFAULT 'system',
  action            TEXT NOT NULL,
  resource_type     TEXT NOT NULL,
  resource_id       TEXT,
  details           JSONB,
  ip_address        INET,
  user_agent        TEXT,
  success           BOOLEAN NOT NULL DEFAULT true
);

CREATE INDEX idx_audit_timestamp ON audit.log(timestamp DESC);
CREATE INDEX idx_audit_user_email ON audit.log(user_email);
CREATE INDEX idx_audit_action ON audit.log(action);

-- ========================================
-- ROW LEVEL SECURITY (RLS)
-- ========================================

ALTER TABLE identities.account ENABLE ROW LEVEL SECURITY;
ALTER TABLE claims.claim ENABLE ROW LEVEL SECURITY;
ALTER TABLE evidence.bundle ENABLE ROW LEVEL SECURITY;
ALTER TABLE ledger.entry ENABLE ROW LEVEL SECURITY;

-- Users see own records
CREATE POLICY account_self_select ON identities.account
  FOR SELECT
  USING (email = current_setting('app.current_user_email', true));

-- Admins see all
CREATE POLICY account_admin_select ON identities.account
  FOR SELECT
  USING (current_setting('app.current_user_roles', true)::text[] && ARRAY['owner', 'admin']);

-- Claims: self or admin
CREATE POLICY claim_self_select ON claims.claim
  FOR SELECT
  USING (subject_id = current_setting('app.current_user_subject_id', true));

CREATE POLICY claim_admin_select ON claims.claim
  FOR SELECT
  USING (current_setting('app.current_user_roles', true)::text[] && ARRAY['owner', 'admin']);

-- Evidence: creator/subject or admin
CREATE POLICY evidence_self_select ON evidence.bundle
  FOR SELECT
  USING (
    subject_id = current_setting('app.current_user_subject_id', true) OR
    created_by = current_setting('app.current_user_email', true)
  );

CREATE POLICY evidence_admin_select ON evidence.bundle
  FOR SELECT
  USING (current_setting('app.current_user_roles', true)::text[] && ARRAY['owner', 'admin']);

-- Ledger: admin only
CREATE POLICY ledger_admin_select ON ledger.entry
  FOR SELECT
  USING (current_setting('app.current_user_roles', true)::text[] && ARRAY['owner', 'admin']);

-- ========================================
-- APPLICATION ROLE
-- ========================================

-- Create app role (idempotent-safe with DO block)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'genesis_app') THEN
    CREATE ROLE genesis_app LOGIN;
  END IF;
END
$$;

GRANT USAGE ON SCHEMA identities TO genesis_app;
GRANT USAGE ON SCHEMA claims TO genesis_app;
GRANT USAGE ON SCHEMA evidence TO genesis_app;
GRANT USAGE ON SCHEMA ledger TO genesis_app;
GRANT USAGE ON SCHEMA audit TO genesis_app;

GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA identities TO genesis_app;
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA claims TO genesis_app;
GRANT SELECT, INSERT ON ALL TABLES IN SCHEMA evidence TO genesis_app;
GRANT SELECT, INSERT ON ALL TABLES IN SCHEMA ledger TO genesis_app;
GRANT SELECT, INSERT ON ALL TABLES IN SCHEMA audit TO genesis_app;

GRANT USAGE ON ALL SEQUENCES IN SCHEMA identities TO genesis_app;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA claims TO genesis_app;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA evidence TO genesis_app;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA ledger TO genesis_app;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA audit TO genesis_app;
